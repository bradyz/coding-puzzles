
order doesn't matter
duplicates matter
# L1 [0,1,2]
# L2 [0,1,2,2,3]

is_sublist(L1, L2) == true

# L1 [0,1,2,2]
# L2 [0,1,2,3]

is_sublist(L1, L2) == false

from collections import Counter

# {0: 1, 1: 1, 2: 1}
# {0: 1: 1: 1, 2: 2, 3: 1}

def is_sublist(l1, l2):
  is_sub = True
  c1 = Counter()
  c2 = Counter()
  for x in l1:
    c1[x] += 1 ###
    for x in l2:
    c2[x] += 1
    for x in l1.keys():
      if x in l2.keys() and l1[x] <= l2[x]:
      continue
      else:
      is_sub = False
      break
      return is_sub

####

      [ 1 0 0 1  ]
      [ 1 0 1 0  ] == 3
      [ 1 0 1 0  ]
      [ 1 0 1 0  ]

## blobs == adjacently connected groupings of true values

      [1 0]
      [0 1]

      [1 1]
      [0 1]

      from collection import DefaultDict

      def count_blobs(grid, wid, len):
## Returns the number of blobs
## (0, 0)
        visited = [][] ## how to instantiate 2d array
        blobs = 0
        for x in range(wid):
          for y in range(len):
            if visited[x][y] == 0 and grid[x][y] == 1:
            blobs += 1
            mark_neighbors(x, y) ### flood
            elif grid[x][y] == 0:
            visited[x][y] = 1
            else:
            visited[x][y] = 1

            def mark_neighbors(x, y):
# x - 1, y
# x + 1, y
# x, y - 1 
# x, y + 1
              for a in [-1, 1]:
              for b in [-1, 1]:
if (x + a < width) and (x + a > 0) and (y + a < len) and (y + a > 0) 
  and grid[x + a][y + b] == 1 and visited[x + a][y + b] == 0:
  visited[x + a][y + b] = 1
mark_neighbors(x + a, y + b)
  return blobs

